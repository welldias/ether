#include <allegro5/allegro.h>
#include <Ether.h>
#include "ether_private.h"
#include "ether_drivers.h"

#define _ETHER_DRIVERS_SCREEN_UNITY                 (1L << _ETHER_SCREEN_FRACT_BITS)
#define _ETHER_DRIVERS_SCREEN_HALF_UNITY            (1L << (_ETHER_SCREEN_FRACT_BITS-1))
#define _ETHER_DRIVERS_SCREEN_HALF_MASK             (_ETHER_DRIVERS_SCREEN_UNITY - 1)
#define _ETHER_DRIVERS_NUMSPECS                     10

#define _ETHER_DRIVERS_SETPIXEL(buff, x, y, color)  buff[_ether_drivers_line_table[(y)+_ether_drivers_top_border]+(x)+_ether_drivers_left_border] = (color)
#define _ETHER_DRIVERS_S2I(a)                       ((a) >> _ETHER_SCREEN_FRACT_BITS)
#define _ETHER_DRIVERS_HFILL(buff, x1, x2, y, color) \
	if (x1 <= x2) \
		memset(&buff[_ether_drivers_line_table[y] + (x1)], (color), (x2) - (x1) + 1)

/* #define FITTING 1 */
#ifdef FITTING
#define _ETHER_DRIVERS_ROUND_DOWN(a) (_ETHER_DRIVERS_S2I(a) - (((a) & _ETHER_DRIVERS_SCREEN_HALF_MASK) ? 0 : 1))
#define _ETHER_DRIVERS_ROUND_UP(a)    _ETHER_DRIVERS_S2I((a) + _ETHER_DRIVERS_SCREEN_UNITY - 1)
#else
#define _ETHER_DRIVERS_ROUND_DOWN(a)  _ETHER_DRIVERS_S2I(a)
#define _ETHER_DRIVERS_ROUND_UP(a)   (_ETHER_DRIVERS_S2I((a)+_ETHER_DRIVERS_SCREEN_HALF_UNITY))
#endif

typedef struct
{
	int startx;
	int endx;
	int startcolor;
	int endcolor;
} EtherDriversSpan;

static EtherRaster       *_ether_drivers_our_raster     = NULL;
static unsigned int      *_ether_drivers_line_table     = NULL;
static EtherFactor       *_ether_drivers_slope_table    = NULL;
static EtherDriversSpan   _ether_drivers_spans[500];
static unsigned char      _ether_drivers_specular_table[_ETHER_DRIVERS_NUMSPECS][256];
static unsigned char     *_ether_drivers_spectable      = NULL;
static int                _ether_drivers_text_x         = 0;
static int                _ether_drivers_text_y         = 0;
static int                _ether_drivers_top_border;
static int                _ether_drivers_left_border;
static EtherOutputvertex *_ether_drivers_topvertex;
static EtherOutputvertex *_ether_drivers_botvertex;
static int                _ether_drivers_starty;          /* starting Y coordinate for the poly being processed */
static int                _ether_drivers_endy;            /* ending Y coordinate for the poly being processed */
static unsigned char      _ether_drivers_masks[]        = { 0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01 };
static int                _ether_drivers_dither[4][4]   = {
	{((15-(0)) <<4),((15-(8)) << 4),((15-(2)) << 4),((15-(10))<< 4)},
	{((15-(12))<<4),((15-(4)) << 4),((15-(14))<< 4),((15-(6)) << 4)},
	{((15-(3)) <<4),((15-(11))<< 4),((15-(1)) << 4),((15-(9)) << 4)},
	{((15-(15))<<4),((15-(7)) << 4),((15-(13))<< 4),((15-(5)) << 4)},
};

#if 1
static EtherRaster        _ether_drivers_video_raster   =
{
	640, /* width  */
	480, /* height */
    8, /* depth  */ 
	  0, /* top */
	  0, /* left */
	639, /* right */
	479, /* bottom   */
	640, /* rowbytes */ 
	NULL
};
#else
static Ether_Raster        _ether_drivers_video_raster   =
{
	320, /* width  */
	200, /* height */
    8, /* depth  */ 
	  0, /* top */
	  0, /* left */
	319, /* right */
	199, /* bottom */
	320, /* rowbytes */ 
	NULL
};
#endif

ALLEGRO_DISPLAY *_drivers_display = NULL;

unsigned char table_data[] = "`~!@#$%^&*()_+{}[]:;<>?/,.`~!@#$%^&*()_+{}[]:;<>?/,.`~!@#$%^&*()_+{}[]:;<>?/,.`~!@#$%^&*()_+{}[]:;<>?/,.`~!@#$%^&*()_+{}[]:;<>?/,.`~!@#$%^&*()_+{}[]:;<>?/,.`~!@#$%^&*()_+{}[]:;<>?/,.`~!@#$%^&*()_+{}[]:;<>?/,.`~!@#$%^&*()_+{}[]:;<>?/,.`~!@#$%^&*()_+{}[]:;<";

static unsigned char _ether_drivers_chartable[][8] = 
{
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x7E,0x81,0xA5,0x81,0xBD,0x99,0x81,0x7E},
	{0x7C,0xFE,0xD6,0xBA,0xC6,0xFE,0x7C,0x00},
	{0xC6,0xEE,0xFE,0xFE,0x7C,0x38,0x10,0x00},
	{0x10,0x38,0x7C,0xFE,0x7C,0x38,0x10,0x00},
	{0x10,0x38,0x10,0xEE,0xEE,0x10,0x38,0x00},
	{0x38,0x7C,0xFE,0xFE,0x6C,0x10,0x38,0x00},
	{0x00,0x18,0x3C,0x7E,0x3C,0x18,0x00,0x00},
	{0xFF,0xE7,0xC3,0x81,0xC3,0xE7,0xFF,0xFF},
	{0x00,0x18,0x3C,0x66,0x66,0x3C,0x18,0x00},
	{0xFF,0xE7,0xC3,0x99,0x99,0xC3,0xE7,0xFF},
	{0x1E,0x0E,0x1E,0x36,0x78,0xCC,0xCC,0x78},
	{0x7E,0xC3,0xC3,0x7E,0x18,0x7E,0x18,0x18},
	{0x1E,0x1A,0x1E,0x18,0x18,0x70,0xF0,0x60},
	{0x3E,0x3E,0x36,0x36,0xF6,0x66,0x1E,0x0C},
	{0xDB,0x3C,0x66,0xE7,0x66,0x3C,0xDB,0x00},
	{0x80,0xC0,0xF0,0xF8,0xF0,0xC0,0x80,0x00},
	{0x02,0x06,0x1E,0x3E,0x1E,0x06,0x02,0x00},
	{0x18,0x3C,0x7E,0x18,0x7E,0x3C,0x18,0x00},
	{0x66,0x66,0x66,0x66,0x66,0x00,0x66,0x00},
	{0x7F,0xDB,0x7B,0x3B,0x1B,0x1B,0x1B,0x00},
	{0x3C,0x66,0x38,0x6C,0x6C,0x38,0xCC,0x78},
	{0x00,0x00,0x00,0x00,0xFE,0xFE,0xFE,0x00},
	{0x18,0x3C,0x7E,0x18,0x7E,0x3C,0x18,0x7E},
	{0x18,0x3C,0x7E,0x18,0x18,0x18,0x18,0x00},
	{0x18,0x18,0x18,0x18,0x7E,0x3C,0x18,0x00},
	{0x00,0x18,0x1C,0xFE,0x1C,0x18,0x00,0x00},
	{0x00,0x30,0x70,0xFE,0x70,0x30,0x00,0x00},
	{0x00,0x00,0xC0,0xC0,0xC0,0xFE,0x00,0x00},
	{0x00,0x24,0x66,0xFF,0x66,0x24,0x00,0x00},
	{0x00,0x10,0x38,0x7C,0x7C,0xFE,0x00,0x00},
	{0x00,0xFE,0x7C,0x7C,0x38,0x10,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x18,0x3C,0x3C,0x18,0x18,0x00,0x18,0x00},
	{0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00},
	{0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00},
	{0x18,0x7E,0xC0,0x7C,0x06,0xFC,0x18,0x00},
	{0x00,0xC6,0x0C,0x18,0x30,0x60,0xC6,0x00},
	{0x38,0x6C,0x38,0x76,0xCC,0xCC,0x76,0x00},
	{0x18,0x18,0x30,0x00,0x00,0x00,0x00,0x00},
	{0x18,0x30,0x60,0x60,0x60,0x30,0x18,0x00},
	{0x60,0x30,0x18,0x18,0x18,0x30,0x60,0x00},
	{0x00,0xEE,0x7C,0xFE,0x7C,0xEE,0x00,0x00},
	{0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x18,0x18,0x30,0x00},
	{0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x38,0x38,0x00},
	{0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00},
	{0x7C,0xC6,0xCE,0xDE,0xF6,0xE6,0x7C,0x00},
	{0x18,0x78,0x18,0x18,0x18,0x18,0x7E,0x00},
	{0x7C,0xC6,0x0C,0x18,0x30,0x66,0xFE,0x00},
	{0x7C,0xC6,0x06,0x3C,0x06,0xC6,0x7C,0x00},
	{0x0C,0x1C,0x3C,0x6C,0xFE,0x0C,0x0C,0x00},
	{0xFE,0xC0,0xFC,0x06,0x06,0xC6,0x7C,0x00},
	{0x7C,0xC6,0xC0,0xFC,0xC6,0xC6,0x7C,0x00},
	{0xFE,0xC6,0x06,0x0C,0x18,0x18,0x18,0x00},
	{0x7C,0xC6,0xC6,0x7C,0xC6,0xC6,0x7C,0x00},
	{0x7C,0xC6,0xC6,0x7E,0x06,0xC6,0x7C,0x00},
	{0x00,0x1C,0x1C,0x00,0x00,0x1C,0x1C,0x00},
	{0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x30},
	{0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x00},
	{0x00,0x00,0xFE,0x00,0x00,0xFE,0x00,0x00},
	{0x60,0x30,0x18,0x0C,0x18,0x30,0x60,0x00},
	{0x7C,0xC6,0x06,0x0C,0x18,0x00,0x18,0x00},
	{0x7C,0xC6,0xC6,0xDE,0xDC,0xC0,0x7E,0x00},
	{0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0x00},
	{0xFC,0x66,0x66,0x7C,0x66,0x66,0xFC,0x00},
	{0x3C,0x66,0xC0,0xC0,0xC0,0x66,0x3C,0x00},
	{0xF8,0x6C,0x66,0x66,0x66,0x6C,0xF8,0x00},
	{0xFE,0xC2,0xC0,0xF8,0xC0,0xC2,0xFE,0x00},
	{0xFE,0x62,0x60,0x7C,0x60,0x60,0xF0,0x00},
	{0x7C,0xC6,0xC0,0xC0,0xDE,0xC6,0x7C,0x00},
	{0xC6,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0x00},
	{0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00},
	{0x3C,0x18,0x18,0x18,0xD8,0xD8,0x70,0x00},
	{0xC6,0xCC,0xD8,0xF0,0xD8,0xCC,0xC6,0x00},
	{0xF0,0x60,0x60,0x60,0x60,0x62,0xFE,0x00},
	{0xC6,0xEE,0xFE,0xD6,0xD6,0xC6,0xC6,0x00},
	{0xC6,0xE6,0xE6,0xF6,0xDE,0xCE,0xC6,0x00},
	{0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00},
	{0xFC,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00},
	{0x7C,0xC6,0xC6,0xC6,0xC6,0xD6,0x7C,0x06},
	{0xFC,0xC6,0xC6,0xFC,0xD8,0xCC,0xC6,0x00},
	{0x7C,0xC6,0xC0,0x7C,0x06,0xC6,0x7C,0x00},
	{0x7E,0x5A,0x18,0x18,0x18,0x18,0x3C,0x00},
	{0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00},
	{0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x10,0x00},
	{0xC6,0xC6,0xD6,0xD6,0xFE,0xEE,0xC6,0x00},
	{0xC6,0x6C,0x38,0x38,0x38,0x6C,0xC6,0x00},
	{0x66,0x66,0x66,0x3C,0x18,0x18,0x3C,0x00},
	{0xFE,0x86,0x0C,0x18,0x30,0x62,0xFE,0x00},
	{0x7C,0x60,0x60,0x60,0x60,0x60,0x7C,0x00},
	{0xC0,0x60,0x30,0x18,0x0C,0x06,0x02,0x00},
	{0x7C,0x0C,0x0C,0x0C,0x0C,0x0C,0x7C,0x00},
	{0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF},
	{0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x78,0x0C,0x7C,0xCC,0x7E,0x00},
	{0xE0,0x60,0x7C,0x66,0x66,0x66,0xFC,0x00},
	{0x00,0x00,0x7C,0xC6,0xC0,0xC6,0x7C,0x00},
	{0x1C,0x0C,0x7C,0xCC,0xCC,0xCC,0x7E,0x00},
	{0x00,0x00,0x7C,0xC6,0xFE,0xC0,0x7C,0x00},
	{0x1C,0x36,0x30,0xFC,0x30,0x30,0x78,0x00},
	{0x00,0x00,0x76,0xCE,0xC6,0x7E,0x06,0x7C},
	{0xE0,0x60,0x7C,0x66,0x66,0x66,0xE6,0x00},
	{0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00},
	{0x0C,0x00,0x1C,0x0C,0x0C,0x0C,0xCC,0x78},
	{0xE0,0x60,0x66,0x6C,0x78,0x6C,0xE6,0x00},
	{0x18,0x18,0x18,0x18,0x18,0x18,0x1C,0x00},
	{0x00,0x00,0x6C,0xFE,0xD6,0xD6,0xC6,0x00},
	{0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x00},
	{0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7C,0x00},
	{0x00,0x00,0xDC,0x66,0x66,0x7C,0x60,0xF0},
	{0x00,0x00,0x76,0xCC,0xCC,0x7C,0x0C,0x1E},
	{0x00,0x00,0xDC,0x66,0x60,0x60,0xF0,0x00},
	{0x00,0x00,0x7C,0xC0,0x7C,0x06,0x7C,0x00},
	{0x30,0x30,0xFC,0x30,0x30,0x36,0x1C,0x00},
	{0x00,0x00,0xCC,0xCC,0xCC,0xCC,0x76,0x00},
	{0x00,0x00,0xC6,0xC6,0x6C,0x38,0x10,0x00},
	{0x00,0x00,0xC6,0xC6,0xD6,0xFE,0x6C,0x00},
	{0x00,0x00,0xC6,0x6C,0x38,0x6C,0xC6,0x00},
	{0x00,0x00,0xC6,0xC6,0xCE,0x76,0x06,0x7C},
	{0x00,0x00,0xFC,0x98,0x30,0x64,0xFC,0x00},
	{0x0E,0x18,0x18,0x70,0x18,0x18,0x0E,0x00},
	{0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00},
	{0x70,0x18,0x18,0x0E,0x18,0x18,0x70,0x00},
	{0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x10,0x38,0x38,0x6C,0x6C,0xFE,0x00},
	{0x3C,0x66,0xC0,0x66,0x3C,0x18,0xCC,0x78},
	{0x00,0xC6,0x00,0xC6,0xC6,0xCE,0x76,0x00},
	{0x0E,0x00,0x7C,0xC6,0xFE,0xC0,0x7C,0x00},
	{0x7C,0xC6,0x78,0x0C,0x7C,0xCC,0x7E,0x00},
	{0xC6,0x00,0x78,0x0C,0x7C,0xCC,0x7E,0x00},
	{0xE0,0x00,0x78,0x0C,0x7C,0xCC,0x7E,0x00},
	{0x38,0x38,0x78,0x0C,0x7C,0xCC,0x7E,0x00},
	{0x00,0x00,0x7C,0xC0,0x7C,0x18,0x6C,0x38},
	{0x7C,0xC6,0x7C,0xC6,0xFE,0xC0,0x7C,0x00},
	{0xC6,0x00,0x7C,0xC6,0xFE,0xC0,0x7C,0x00},
	{0xE0,0x00,0x7C,0xC6,0xFE,0xC0,0x7C,0x00},
	{0x66,0x00,0x38,0x18,0x18,0x18,0x3C,0x00},
	{0x7C,0xC6,0x38,0x18,0x18,0x18,0x3C,0x00},
	{0xE0,0x00,0x38,0x18,0x18,0x18,0x3C,0x00},
	{0xC6,0x38,0x6C,0xC6,0xFE,0xC6,0xC6,0x00},
	{0x38,0x38,0x00,0x7C,0xC6,0xFE,0xC6,0x00},
	{0x0E,0x00,0xFE,0xC0,0xF8,0xC0,0xFE,0x00},
	{0x00,0x00,0x6C,0x9A,0x7E,0xD8,0x6E,0x00},
	{0x7E,0xD8,0xD8,0xFE,0xD8,0xD8,0xDE,0x00},
	{0x7C,0xC6,0x00,0x7C,0xC6,0xC6,0x7C,0x00},
	{0x00,0xC6,0x00,0x7C,0xC6,0xC6,0x7C,0x00},
	{0x00,0xE0,0x00,0x7C,0xC6,0xC6,0x7C,0x00},
	{0x7C,0xC6,0x00,0xC6,0xC6,0xCE,0x76,0x00},
	{0x00,0xE0,0x00,0xC6,0xC6,0xCE,0x76,0x00},
	{0x00,0xC6,0x00,0xC6,0xCE,0x76,0x06,0x7C},
	{0xC6,0x38,0x6C,0xC6,0xC6,0x6C,0x38,0x00},
	{0xC6,0x00,0xC6,0xC6,0xC6,0xC6,0x7C,0x00},
	{0x00,0x18,0x7E,0xD8,0xD8,0x7E,0x18,0x00},
	{0x38,0x6C,0x60,0xF0,0x66,0xF6,0x6C,0x00},
	{0xC3,0x66,0x3C,0x7E,0x18,0x3C,0x18,0x00},
	{0xFC,0xC6,0xFC,0xCC,0xDE,0xCC,0xCE,0x00},
	{0x0C,0x1E,0x18,0x7E,0x18,0x18,0xD8,0x70},
	{0x0E,0x00,0x78,0x0C,0x7C,0xCC,0x7E,0x00},
	{0x1C,0x00,0x38,0x18,0x18,0x18,0x3C,0x00},
	{0x00,0x0E,0x00,0x7C,0xC6,0xC6,0x7C,0x00},
	{0x00,0x0E,0x00,0xCC,0xCC,0xDC,0x76,0x00},
	{0x00,0xFC,0x00,0xBC,0x66,0x66,0xE6,0x00},
	{0xFE,0x00,0xC6,0xE6,0xF6,0xCE,0xC6,0x00},
	{0x38,0x6C,0x3E,0x00,0x7E,0x00,0x00,0x00},
	{0x7C,0xC6,0x7C,0x00,0x7C,0x00,0x00,0x00},
	{0x18,0x00,0x18,0x30,0x60,0x66,0x3C,0x00},
	{0x00,0x00,0x00,0x7C,0x60,0x60,0x00,0x00},
	{0x00,0x00,0x00,0x7C,0x0C,0x0C,0x00,0x00},
	{0xC0,0xCC,0xD8,0x30,0x7C,0x36,0x0C,0x3E},
	{0xC0,0xCC,0xD8,0x30,0x6C,0x3C,0x7E,0x0C},
	{0x18,0x00,0x18,0x18,0x3C,0x3C,0x18,0x00},
	{0x00,0x36,0x6C,0xD8,0x6C,0x36,0x00,0x00},
	{0x00,0xD8,0x6C,0x36,0x6C,0xD8,0x00,0x00},
	{0x22,0x88,0x22,0x88,0x22,0x88,0x22,0x88},
	{0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA},
	{0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77},
	{0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18},
	{0x18,0x18,0x18,0x18,0xF8,0x18,0x18,0x18},
	{0x18,0x18,0xF8,0x18,0xF8,0x18,0x18,0x18},
	{0x36,0x36,0x36,0x36,0xF6,0x36,0x36,0x36},
	{0x00,0x00,0x00,0x00,0xFE,0x36,0x36,0x36},
	{0x00,0x00,0xF8,0x18,0xF8,0x18,0x18,0x18},
	{0x36,0x36,0xF6,0x06,0xF6,0x36,0x36,0x36},
	{0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36},
	{0x00,0x00,0xFE,0x06,0xF6,0x36,0x36,0x36},
	{0x36,0x36,0xF6,0x06,0xFE,0x00,0x00,0x00},
	{0x36,0x36,0x36,0x36,0xFE,0x00,0x00,0x00},
	{0x18,0x18,0xF8,0x18,0xF8,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0xF8,0x18,0x18,0x18},
	{0x18,0x18,0x18,0x18,0x1F,0x00,0x00,0x00},
	{0x18,0x18,0x18,0x18,0xFF,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0xFF,0x18,0x18,0x18},
	{0x18,0x18,0x18,0x18,0x1F,0x18,0x18,0x18},
	{0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00},
	{0x18,0x18,0x18,0x18,0xFF,0x18,0x18,0x18},
	{0x18,0x18,0x1F,0x18,0x1F,0x18,0x18,0x18},
	{0x36,0x36,0x36,0x36,0x37,0x36,0x36,0x36},
	{0x36,0x36,0x37,0x30,0x3F,0x00,0x00,0x00},
	{0x00,0x00,0x3F,0x30,0x37,0x36,0x36,0x36},
	{0x36,0x36,0xF7,0x00,0xFF,0x00,0x00,0x00},
	{0x00,0x00,0xFF,0x00,0xF7,0x36,0x36,0x36},
	{0x36,0x36,0x37,0x30,0x37,0x36,0x36,0x36},
	{0x00,0x00,0xFF,0x00,0xFF,0x00,0x00,0x00},
	{0x36,0x36,0xF7,0x00,0xF7,0x36,0x36,0x36},
	{0x18,0x18,0xFF,0x00,0xFF,0x00,0x00,0x00},
	{0x36,0x36,0x36,0x36,0xFF,0x00,0x00,0x00},
	{0x00,0x00,0xFF,0x00,0xFF,0x18,0x18,0x18},
	{0x00,0x00,0x00,0x00,0xFF,0x36,0x36,0x36},
	{0x36,0x36,0x36,0x36,0x3F,0x00,0x00,0x00},
	{0x18,0x18,0x1F,0x18,0x1F,0x00,0x00,0x00},
	{0x00,0x00,0x1F,0x18,0x1F,0x18,0x18,0x18},
	{0x00,0x00,0x00,0x00,0x3F,0x36,0x36,0x36},
	{0x36,0x36,0x36,0x36,0xFF,0x36,0x36,0x36},
	{0x18,0x18,0xFF,0x18,0xFF,0x18,0x18,0x18},
	{0x18,0x18,0x18,0x18,0xF8,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x1F,0x18,0x18,0x18},
	{0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},
	{0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF},
	{0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0},
	{0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F},
	{0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x66,0xDC,0xD8,0xDC,0x66,0x00},
	{0x78,0xCC,0xF8,0xCC,0xE6,0xDC,0xC0,0x00},
	{0x00,0xFE,0x62,0x60,0x60,0x60,0xE0,0x00},
	{0x00,0xFE,0x6C,0x6C,0x6C,0x6C,0x6C,0x00},
	{0xFE,0xC6,0x60,0x30,0x60,0xC6,0xFE,0x00},
	{0x00,0x7E,0xD8,0xCC,0xCC,0xD8,0x70,0x00},
	{0x00,0x66,0x66,0x66,0x66,0x7C,0xC0,0x00},
	{0x00,0x76,0xDC,0x18,0x18,0x18,0x38,0x00},
	{0xFE,0x38,0x6C,0xC6,0x6C,0x38,0xFE,0x00},
	{0x38,0x6C,0xC6,0xFE,0xC6,0x6C,0x38,0x00},
	{0x38,0x6C,0xC6,0xC6,0x6C,0x6C,0xEE,0x00},
	{0x3E,0x60,0x38,0x66,0xC6,0xCC,0x78,0x00},
	{0x00,0x00,0x7E,0xDB,0xDB,0x7E,0x00,0x00},
	{0x06,0x7C,0xDE,0xF6,0xE6,0x7C,0xC0,0x00},
	{0x38,0x60,0xC0,0xF8,0xC0,0x60,0x38,0x00},
	{0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x00},
	{0x00,0xFE,0x00,0xFE,0x00,0xFE,0x00,0x00},
	{0x18,0x18,0x7E,0x18,0x18,0x00,0x7E,0x00},
	{0x30,0x18,0x0C,0x18,0x30,0x00,0x7E,0x00},
	{0x0C,0x18,0x30,0x18,0x0C,0x00,0x7E,0x00},
	{0x0C,0x1E,0x18,0x18,0x18,0x18,0x18,0x18},
	{0x18,0x18,0x18,0x18,0x18,0x78,0x30,0x00},
	{0x00,0x00,0x18,0x00,0x7E,0x00,0x18,0x00},
	{0x00,0x76,0xDC,0x00,0x76,0xDC,0x00,0x00},
	{0x7C,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00},
	{0x1F,0x18,0x18,0x18,0xF8,0x38,0x18,0x00},
	{0xD8,0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00},
	{0x70,0xD8,0x30,0xF8,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x7C,0x7C,0x7C,0x7C,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0}
};

static void   _ether_drivers_render_gouraud_poly       (void);
static void   _ether_drivers_render_dithered_poly      (void);
static void   _ether_drivers_render_fast_dithered_poly (void);
static void   _ether_drivers_render_specular_poly      (void);
static void   _ether_drivers_specular_update           (EtherPalette *palette);
static int    _ether_drivers_compute_line_table        (void);
static int    _ether_drivers_compute_slope_table       (void);
static void   _ether_drivers_glass_fill                (int y, int off, unsigned char color);
static int    _ether_drivers_render_lines              (EtherOutputvertex *list, int closed);
static void   _ether_drivers_render_flat_poly          (EtherColor color);
static void   _ether_drivers_render_metal_poly         (EtherColor color);
static void   _ether_drivers_render_glass_poly         (EtherColor color);
static int    _ether_drivers_render_char               (int x, int y, unsigned char c, unsigned char color);
static void   _ether_drivers_find_top                  (EtherOutputvertex *list);
static int    _ether_drivers_scan_left_edge            (EtherOutputvertex *first, EtherOutputvertex *last);
static int    _ether_drivers_scan_right_edge           (EtherOutputvertex *first, EtherOutputvertex *last);
static int    _ether_drivers_scan_outline              (EtherOutputvertex *list);
static int    _ether_drivers_gscan_left_edge           (EtherOutputvertex *first, EtherOutputvertex *last);
static int    _ether_drivers_gscan_right_edge          (EtherOutputvertex *first, EtherOutputvertex *last);
static int    _ether_drivers_gscan_outline             (EtherOutputvertex *list, void (*render_func)(void));
static void (*_ether_drivers_shadefunc)                (void) = _ether_drivers_render_dithered_poly;

int 
ether_drivers_display_default(EtherDisplayCommand cmd, int lparm1, void *pparm1)
{
	switch (cmd)
	{
		case ETHER_DISPLAY_GET_VERSION: 
			return 1;
		case ETHER_DISPLAY_GET_DESCRIPTION: 
			strncpy((char *) pparm1, "Microsoft Window32", lparm1); 
			return 0;
		case ETHER_DISPLAY_INIT:
		{
			EtherRaster *hardware_raster = ether_video_raster_get();

			if (pparm1)
			{
				_ether_drivers_our_raster = pparm1;
			}
			else
			{
				_ether_drivers_our_raster = ether_raster_create(
					ether_raster_width_get(hardware_raster),
					ether_raster_height_get(hardware_raster),
					ether_raster_depth_get(hardware_raster));
				if(_ether_drivers_our_raster == NULL)
					return -1;
			}

      if (!al_init()) {
        return -1;
      }

      al_install_keyboard();

      _drivers_display = al_create_display(
          ether_raster_width_get (_ether_drivers_our_raster),
          ether_raster_height_get(_ether_drivers_our_raster));
      if (!_drivers_display) {
        return -1;
      }

			if(_ether_drivers_compute_slope_table())
				return -2;
			if(_ether_drivers_compute_line_table())
				return -3;

		}
		case ETHER_DISPLAY_CLEAR: 
		{
			unsigned char *data = ether_raster_data_get(_ether_drivers_our_raster);
			int size = ether_raster_size_get(_ether_drivers_our_raster);
			if(data)
				memset(data, lparm1, size);
			break;
		}
    case ETHER_DISPLAY_QUIT:
      al_destroy_display(_drivers_display);
      break;
		case ETHER_DISPLAY_POINT:
		{
			EtherOutputvertex *vertlist = (EtherOutputvertex *)pparm1;
			EtherOutputvertex *v        = pparm1;
			unsigned char *data = ether_raster_data_get(_ether_drivers_our_raster);
			if(data)
			{
				do
				{
					_ETHER_DRIVERS_SETPIXEL(data, _ETHER_DRIVERS_S2I(v->x), _ETHER_DRIVERS_S2I(v->y), v->red);
    				v = v->next;
				} while(v != vertlist);
			}
			break;
		}
		case ETHER_DISPLAY_LINE: 
			_ether_drivers_render_lines(pparm1, 0);
			break;
		case ETHER_DISPLAY_CLOSED_LINE: 
			_ether_drivers_render_lines(pparm1, 1);
            break;
		case ETHER_DISPLAY_POLY:
		{
			EtherOutputfacet *f = pparm1;
			switch(f->surface->type)
			{
			case ETHER_SURF_METAL:
				if (!_ether_drivers_scan_outline(f->points))
					_ether_drivers_render_metal_poly(f->color);
				break;
			case ETHER_SURF_GLASS:
				if (!_ether_drivers_scan_outline(f->points))
					_ether_drivers_render_glass_poly(f->color);
				break;
			case ETHER_SURF_SPECULAR:
				_ether_drivers_spectable = _ether_drivers_specular_table[f->surface->exponent];
				_ether_drivers_gscan_outline(f->points, _ether_drivers_render_specular_poly);
				break;
			case ETHER_SURF_GOURAUD:
				if(_ether_drivers_shadefunc)
				{
					_ether_drivers_gscan_outline(f->points, _ether_drivers_shadefunc);
					break;
				}
			default:
				if (!_ether_drivers_scan_outline(f->points))
					_ether_drivers_render_flat_poly(f->color);
				break;
			}
			break;
		}
		case ETHER_DISPLAY_BOX:
		{
			EtherOutputvertex *v = pparm1;
			int row;
			int endrow = (int)_ETHER_DRIVERS_S2I(v->next->y);
			int xstart = (int)_ETHER_DRIVERS_S2I(v->x);
			int xend   = (int)_ETHER_DRIVERS_S2I(v->next->x);
			unsigned char *data = ether_raster_data_get(_ether_drivers_our_raster);
			if(!data)
				break;
			for(row = (int)_ETHER_DRIVERS_S2I(v->y); row <= endrow; ++row)
				_ETHER_DRIVERS_HFILL(data, xstart, xend, row, v->red);
			break;
		}
		case ETHER_DISPLAY_BEGIN_FRAME:
			ether_raster_window_get(_ether_drivers_our_raster, &_ether_drivers_left_border, &_ether_drivers_top_border, NULL, NULL);
			break;
		case ETHER_DISPLAY_TEXT:
		{
			int result;
			char *s = pparm1;
			while(*s)
			{
				result = _ether_drivers_render_char(_ether_drivers_text_x, _ether_drivers_text_y, (unsigned char)*s++, (unsigned char)lparm1);
				if(result < 0)
					break;
				_ether_drivers_text_x += result;
			}
			break;
		}
		case ETHER_DISPLAY_TEXT_POSITION: 
			_ether_drivers_text_x =  lparm1 >> 16; 
			_ether_drivers_text_y = (short)lparm1;
			break;
		case ETHER_DISPLAY_GET_TEXTWIDTH: 
			return (int)strlen(pparm1) * 8;
		case ETHER_DISPLAY_GET_TEXTHEIGHT: 
			return 8;
		case ETHER_DISPLAY_SET_RASTER: 
			_ether_drivers_our_raster = pparm1; 
			break;
		case ETHER_DISPLAY_GET_RASTER: 
			*((EtherRaster **) pparm1) = _ether_drivers_our_raster; 
			break;
		case ETHER_DISPLAY_CAN_GOURAUD: 
			return 1;
		case ETHER_DISPLAY_UPDATE_PALETTE: 
			_ether_drivers_specular_update(pparm1); 
			break;
		case ETHER_DISPLAY_SET_SHADING:
			switch (lparm1)
			{
				case 0: _ether_drivers_shadefunc = NULL; break;
				case 1: _ether_drivers_shadefunc = _ether_drivers_render_gouraud_poly; break;
				case 2: _ether_drivers_shadefunc = _ether_drivers_render_fast_dithered_poly; break;
				case 3: _ether_drivers_shadefunc = _ether_drivers_render_fast_dithered_poly; break;
				default: break;
			}
			break;
		default: break;
	}
	return 0;
}

int 
ether_drivers_video_default(EtherVideoCommand cmd, int lparm1, void *pparm1)
{
	switch (cmd)
	{
		case ETHER_VIDEO_GET_VERSION:
			return 1;
		case ETHER_VIDEO_GET_DESCRIPTION: 
			strncpy((char *) pparm1, "Default video Version 0.1", lparm1);
			return 0;
		case ETHER_VIDEO_SETUP:
			return 0;
		case ETHER_VIDEO_SHUTDOWN:
			break;
		case ETHER_VIDEO_GET_MODE:
			return 0;
		case ETHER_VIDEO_SET_DRAW_PAGE:
			break;
		case ETHER_VIDEO_SET_VIEW_PAGE:
			break;
		case ETHER_VIDEO_GET_NPAGES:
			return 1;
		case ETHER_VIDEO_HAS_PALETTE:
			return 1;
		case ETHER_VIDEO_SET_PALETTE:
			return 0;
		case ETHER_VIDEO_SET_NTSC:
			break;
		case ETHER_VIDEO_CHECK_RETRACE:
			break;
		case ETHER_VIDEO_GET_RASTER:
		{
			*((EtherRaster **) pparm1) = &_ether_drivers_video_raster;
			break;
		}
		case ETHER_VIDEO_BLIT:
    {
      EtherPalette *pal = NULL;
      EtherRaster  *raster = (EtherRaster *)pparm1;

      unsigned char *data = NULL;
      unsigned int x,y;

      al_clear_to_color(al_map_rgb(0,0,0));

      al_lock_bitmap(al_get_backbuffer(_drivers_display), ALLEGRO_PIXEL_FORMAT_ANY, 0);

      pal = ether_world_palette_get();
      data = raster->data;

      for( y = 0; y < raster->height; y++ )
      {
        for( x = 0; x < raster->width; x++ )
        {
          al_put_pixel(x, y, al_map_rgba(
                pal->data[*(data)][0],
                pal->data[*(data)][1],
                pal->data[*(data)][2],
                255));
          data++;
        }
      }

      al_unlock_bitmap(al_get_backbuffer(_drivers_display));
      al_flip_display();

#if 0
			int x;
			int y;
			unsigned short color     = 0;
			ether_raster *our_raster = (ether_raster *) pparm1;
			unsigned char *data      = our_raster->data;
			int width                = our_raster->width;
			int height               = our_raster->height;

			FILE* meu_arquivo;
			char arquivo[100] = "/scene.txt";
			char a1 = '*';
			char a2 = ' ';
			char a3 = '\n';
			meu_arquivo = fopen(arquivo, "a+t");
			fwrite(&a3, 1, 1, meu_arquivo);
			fwrite(&a3, 1, 1, meu_arquivo);
			for( x = 0; x < height; x++ ){
				for( y = 0; y < width; y++ ){
					if( *(data) != 0 ){
						color = *(data);
						fwrite(&table_data[color], 1, 1, meu_arquivo);
						*(data) = 0;

					} else {
						fwrite(&a2, 1, 1, meu_arquivo);
					}
					data++;
				}
				fwrite(&a3, 1, 1, meu_arquivo);
			}
			fclose(meu_arquivo);
#endif
      break;
    }
		case ETHER_VIDEO_CURSOR_HIDE:
			break;
		case ETHER_VIDEO_CURSOR_SHOW:
			break;
		case ETHER_VIDEO_CURSOR_RESET:
			break;
		case ETHER_VIDEO_CURSOR_MOVE:
			break;
		case ETHER_VIDEO_CURSOR_SET_APPEARANCE:
			break;
		default:
			break;
	}

	return 0;
}

static void 
_ether_drivers_render_gouraud_poly(void)
{
	int x;
	int y;
	int color;
	int cincrement;
	unsigned char *data = ether_raster_data_get(_ether_drivers_our_raster);
	if(!data)
		return;
	y = (_ether_drivers_endy + _ether_drivers_starty) >> 1;
	cincrement = (int)ether_math_factor_multiply(
		_ether_drivers_slope_table[_ether_drivers_spans[y].endx - _ether_drivers_spans[y].startx], 
		(EtherScalar)(_ether_drivers_spans[y].endcolor - _ether_drivers_spans[y].startcolor));
	for(y = _ether_drivers_starty; y <= _ether_drivers_endy; ++y)
	{
		unsigned char *ptr = &data[_ether_drivers_line_table[y]];
		color = _ether_drivers_spans[y].startcolor;
		for (x = _ether_drivers_spans[y].startx; x <= _ether_drivers_spans[y].endx; ++x)
		{
			ptr[x] = color >> 8;
			color += cincrement;
		}
	}
}

static void 
_ether_drivers_render_dithered_poly(void)
{
	int x;
	int y;
	int color;
	int cincrement;
	unsigned char *data = ether_raster_data_get(_ether_drivers_our_raster);
    
	if(!data)
		return;
	y = (_ether_drivers_endy + _ether_drivers_starty) >> 1;
	cincrement = (int)ether_math_factor_multiply(
		_ether_drivers_slope_table[_ether_drivers_spans[y].endx - _ether_drivers_spans[y].startx],
		(EtherScalar)(_ether_drivers_spans[y].endcolor - _ether_drivers_spans[y].startcolor));
	for(y = _ether_drivers_starty; y <= _ether_drivers_endy; ++y)
	{
		unsigned char *ptr = &data[_ether_drivers_line_table[y]];
		int *dtable = _ether_drivers_dither[y & 3];
		color = _ether_drivers_spans[y].startcolor;
		for(x = _ether_drivers_spans[y].startx; x <= _ether_drivers_spans[y].endx; ++x)
		{
			ptr[x] = ((unsigned int)((color + dtable[x&3]))) >> 8;
			color += cincrement;
		}
	}
}

static void 
_ether_drivers_render_fast_dithered_poly(void)
{
	int x;
	int y;
	int color;
	int cincrement;
	unsigned char *data = ether_raster_data_get(_ether_drivers_our_raster);
	if(!data)
		return;
	y = (_ether_drivers_endy + _ether_drivers_starty) >> 1;
	cincrement = (int)ether_math_factor_multiply(
		_ether_drivers_slope_table[_ether_drivers_spans[y].endx - _ether_drivers_spans[y].startx],
		(EtherScalar)(_ether_drivers_spans[y].endcolor - _ether_drivers_spans[y].startcolor));
	for(y = _ether_drivers_starty; y <= _ether_drivers_endy; ++y)
	{
		unsigned char *ptr = &data[_ether_drivers_line_table[y]];
		int a, b;
		if(y & 1)
		{ 
			a = 1 << 6;
			b = 3 << 6;
		}
		else
		{ 
			a = 2 << 6;
			b = 0 << 6;
		}
		color = _ether_drivers_spans[y].startcolor;
		for(x = _ether_drivers_spans[y].startx; x <= _ether_drivers_spans[y].endx; ++x)
		{
			ptr[x] = ((unsigned int) ((color + ((x&1) ? a : b)))) >> 8;
			color += cincrement;
		}
	}
}

static void 
_ether_drivers_render_specular_poly(void)
{
	int x;
	int y;
	int color;
	int cincrement;
	unsigned char *data = ether_raster_data_get(_ether_drivers_our_raster);
	if(!data)
		return;
	y = (_ether_drivers_endy + _ether_drivers_starty) >> 1;
	cincrement = (int)ether_math_factor_multiply(
		_ether_drivers_slope_table[_ether_drivers_spans[y].endx - _ether_drivers_spans[y].startx],
		(EtherScalar)(_ether_drivers_spans[y].endcolor - _ether_drivers_spans[y].startcolor));
	for(y = _ether_drivers_starty; y <= _ether_drivers_endy; ++y)
	{
		unsigned char *ptr = &data[_ether_drivers_line_table[y]];
		int *dtable = _ether_drivers_dither[y & 3];
		color = _ether_drivers_spans[y].startcolor;
		for (x = _ether_drivers_spans[y].startx; x <= _ether_drivers_spans[y].endx; ++x)
		{
			ptr[x] = _ether_drivers_spectable[((unsigned int) ((color + dtable[x&3]))) >> 8];
			color += cincrement;
		}
	}
}

static void 
_ether_drivers_specular_update(EtherPalette *palette)
{
	unsigned int hue;
	unsigned int shade;
	unsigned int specnum;
	unsigned char value;
	double exponent;
	EtherHue *huemap = ether_palette_huemap_get(palette);
	for(specnum = 0; specnum < _ETHER_DRIVERS_NUMSPECS; ++specnum)
	{
		exponent = 1.0 + 7 * specnum / 100.0;
		for(shade = 0; shade <= huemap[0].maxshade; ++shade)
			_ether_drivers_specular_table[specnum][shade] = shade;
		for(hue = 1; hue < 256 && huemap[hue].maxshade; ++hue)
		{
			for(shade = 0; shade <= huemap[hue].maxshade; ++shade)
			{
				value = (unsigned char)pow(shade, exponent);
				if(value > huemap[hue].maxshade)
					value = huemap[hue].maxshade;
				_ether_drivers_specular_table[specnum][huemap[hue].start + shade] = huemap[hue].start + value;
			}
		}
	}
}

static int 
_ether_drivers_compute_line_table(void)
{
	int i;
	if(_ether_drivers_line_table)
		free(_ether_drivers_line_table);
	_ether_drivers_line_table = calloc(ether_raster_height_get(_ether_drivers_our_raster), sizeof(unsigned int));
	if(_ether_drivers_line_table == NULL)
		return -1;
	for(i = 0; i < ether_raster_height_get(_ether_drivers_our_raster); ++i)
		_ether_drivers_line_table[i] = ether_raster_rowbytes_get(_ether_drivers_our_raster) * i;
	return 0;
}

static int 
_ether_drivers_compute_slope_table(void)
{
	int i;
	int n = max(ether_raster_height_get(_ether_drivers_our_raster), ether_raster_width_get(_ether_drivers_our_raster));
	if(_ether_drivers_slope_table)
		free(_ether_drivers_slope_table);
	_ether_drivers_slope_table = calloc(n, sizeof(EtherFactor));
	if(_ether_drivers_slope_table == NULL)
		return -1;
	_ether_drivers_slope_table[0] = 0;
	for (i = 1; i < n; ++i)
		_ether_drivers_slope_table[i] = ETHER_FLOAT_TO_FACTOR(1.0 / i);
	return 0;
}

static void
_ether_drivers_glass_fill(int y, int off, unsigned char color)
{
	int pixel;
	int x;
	unsigned char *ptr;
	unsigned char *data;
	data = ether_raster_data_get(_ether_drivers_our_raster);
	if(!data)
		return;
	x    = _ether_drivers_spans[y].startx;
	ptr  = &data[_ether_drivers_line_table[y]];
	for(pixel = x + ((x ^ y) & 0x01) ; pixel <= _ether_drivers_spans[y].endx ; pixel += 2)
		ptr[pixel] = color | off;
}

static int 
_ether_drivers_render_lines(EtherOutputvertex *list, int closed)
{
	EtherOutputvertex *v    = list;
	EtherOutputvertex *last = closed ? list : list->prev;
	unsigned char *data = ether_raster_data_get(_ether_drivers_our_raster);
	if(!data)
		return -1;
	do
	{
		int deltax = (int)labs(v->next->x - v->x);
		int deltay = (int)labs(v->next->y - v->y);
		int d, dinc1, dinc2;
		int x, xinc1, xinc2, y, yinc1, yinc2;
		int i, numpixels;
		int color = v->red;
		if(deltax >= deltay)
		{
			numpixels = _ETHER_DRIVERS_S2I(deltax);
			d = (deltay << 1) - deltax;
			dinc1 = deltay << 1;
			dinc2 = (deltay - deltax) << 1;
			xinc1 = _ETHER_DRIVERS_SCREEN_UNITY;  
			xinc2 = _ETHER_DRIVERS_SCREEN_UNITY;
			yinc1 = 0;
			yinc2 = _ETHER_DRIVERS_SCREEN_UNITY;
		}
		else
		{
			numpixels = _ETHER_DRIVERS_S2I(deltay);
			d = (deltax << 1) - deltay;
			dinc1 = deltax << 1;
			dinc2 = (deltax - deltay) << 1;
			xinc1 = 0;
			xinc2 = _ETHER_DRIVERS_SCREEN_UNITY;
			yinc1 = _ETHER_DRIVERS_SCREEN_UNITY;
			yinc2 = _ETHER_DRIVERS_SCREEN_UNITY;
		}
		if(v->x > v->next->x)
		{
			xinc1 = -xinc1;
			xinc2 = -xinc2;
		}
		if(v->y > v->next->y)
		{
			yinc1 = -yinc1;
			yinc2 = -yinc2;
		}
		x = (int)v->x;
        y = (int)v->y;
		for(i = 0; i < numpixels; ++i)
		{
			_ETHER_DRIVERS_SETPIXEL(data, _ETHER_DRIVERS_S2I(x), _ETHER_DRIVERS_S2I(y), color);
			if (d < 0)
			{
				d += dinc1;
				x += xinc1;
				y += yinc1;
			}
			else
			{
				d += dinc2;
				x += xinc2;
				y += yinc2;
			}
		}
		v = v->next;
	} while (v != last);
	return 0;
}

static void 
_ether_drivers_render_flat_poly(EtherColor color)
{
	int y;
	unsigned char *data = ether_raster_data_get(_ether_drivers_our_raster);
	if(!data)
		return;
	for(y = _ether_drivers_starty; y <= _ether_drivers_endy; ++y)
	{
		_ETHER_DRIVERS_HFILL(data, _ether_drivers_spans[y].startx, _ether_drivers_spans[y].endx, y, color);
	}
}

static void
_ether_drivers_render_metal_poly(EtherColor color)
{
	int y;
	int dir = 1;
	int off = (color & 0x0F) + _ether_drivers_starty;
	unsigned char *data;
	if(off & 0x10)
		off = ~off;
	off &= 0x0F;
	color &= 0xF0;
	data = ether_raster_data_get(_ether_drivers_our_raster);
	if(!data)
		return;
	for(y = _ether_drivers_starty; y <= _ether_drivers_endy; ++y)
	{
		_ETHER_DRIVERS_HFILL(data, _ether_drivers_spans[y].startx, _ether_drivers_spans[y].endx, y, color | off);
		off += dir;
		if(off > 15)
		{ 
			off = 15;
			dir = -1;
		}
		else if(off < 0)
		{ 
			off = 0; 
			dir = 1;
		}
	}
}

static void
_ether_drivers_render_glass_poly(EtherColor color)
{
	int y;
	int dir = 1;
	int off = (color & 0x0F) + _ether_drivers_starty;
	unsigned char *data;
	if(off & 0x10)
		off = ~off;
	off &= 0x0F;
	color &= 0xF0;
	data = ether_raster_data_get(_ether_drivers_our_raster);
	if(!data)
		return;
	for(y = _ether_drivers_starty; y <= _ether_drivers_endy; ++y)
	{
		_ether_drivers_glass_fill(y, off, (unsigned char)color);
		off += dir;
		if(off > 15)
		{
			off = 15;
			dir = -1;
		}
		else if(off < 0)
		{
			off = 0;
			dir = 1;
		}
	}
}

static int
_ether_drivers_render_char(int x, int y, unsigned char c, unsigned char color)
{
	int i;
	int j;
	unsigned int dst   = _ether_drivers_line_table[y+_ether_drivers_top_border] + x + _ether_drivers_left_border;
	unsigned char *src = _ether_drivers_chartable[c];
	unsigned char *data = ether_raster_data_get(_ether_drivers_our_raster);
	if(!data)
		return -1;
	for(i = 0; i < 8; ++i)
	{
		for(j = 0; j < 8; ++j)
			if(src[i] & _ether_drivers_masks[j])
				data[dst+j] = color;
		dst += ether_raster_rowbytes_get(_ether_drivers_our_raster);
	}
	return 8;
}

static void 
_ether_drivers_find_top(EtherOutputvertex *list)
{
	EtherOutputvertex *v    = list;
	_ether_drivers_topvertex = list;
	_ether_drivers_botvertex = list;
	do
	{
		if (v->y < _ether_drivers_topvertex->y)
			_ether_drivers_topvertex = v;
		else if (v->y > _ether_drivers_botvertex->y)
			_ether_drivers_botvertex = v;
		v = v->next;
	} while (v != list);
	/* find starting and ending scanline numbers */
	_ether_drivers_starty = (int)_ETHER_DRIVERS_ROUND_UP(_ether_drivers_topvertex->y)   + _ether_drivers_top_border;
	_ether_drivers_endy   = (int)_ETHER_DRIVERS_ROUND_DOWN(_ether_drivers_botvertex->y) + _ether_drivers_top_border;
}

static int 
_ether_drivers_scan_left_edge(EtherOutputvertex *first, EtherOutputvertex *last)
{
	int xincrement;
	int x  = (int)first->x + (((int) _ether_drivers_left_border) << _ETHER_SCREEN_FRACT_BITS);
	int y1 = (int)_ETHER_DRIVERS_ROUND_UP(first->y) + _ether_drivers_top_border;
	int y2 = (int)_ETHER_DRIVERS_ROUND_DOWN(last->y) + _ether_drivers_top_border;
	int y;
	if(y2 < y1)
		y2 = y1;
	xincrement = (int)ether_math_factor_multiply(_ether_drivers_slope_table[y2 - y1], (EtherScalar)(last->x - first->x));
	for(y = y1; y <= y2; ++y)
	{
		_ether_drivers_spans[y].startx = _ETHER_DRIVERS_ROUND_UP(x);
		x += xincrement;
	}
	return 0;
}

static int 
_ether_drivers_scan_right_edge(EtherOutputvertex *first, EtherOutputvertex *last)
{
	int xincrement;
	int x  = (int)first->x + (((int) _ether_drivers_left_border) << _ETHER_SCREEN_FRACT_BITS);
	int y1 = (int)_ETHER_DRIVERS_ROUND_UP(first->y) + _ether_drivers_top_border;
	int y2 = (int)_ETHER_DRIVERS_ROUND_DOWN(last->y) + _ether_drivers_top_border;
	int y;
	if(y2 <= y1)
		y2 = y1;
	xincrement = (int)ether_math_factor_multiply(_ether_drivers_slope_table[y2 - y1], (EtherScalar)(last->x - first->x));
	for (y = y1; y <= y2; ++y)
	{
		_ether_drivers_spans[y].endx = _ETHER_DRIVERS_ROUND_DOWN(x);
		x += xincrement;
	}
	return 0;
}

static int 
_ether_drivers_scan_outline(EtherOutputvertex *list)
{
	EtherOutputvertex *v;
	_ether_drivers_find_top(list);
	if(_ether_drivers_starty >= _ether_drivers_endy)
		return 1;
	/* scan convert left-side edges */
	for(v = _ether_drivers_topvertex; v != _ether_drivers_botvertex; v = v->prev)
		if (_ether_drivers_scan_left_edge(v, v->prev))
			return 1;
	/* scan convert right-side edges */
	for(v = _ether_drivers_topvertex; v != _ether_drivers_botvertex; v = v->next)
		if (_ether_drivers_scan_right_edge(v, v->next))
			return 1;
	return 0;
}

static int 
_ether_drivers_gscan_left_edge(EtherOutputvertex *first, EtherOutputvertex *last)
{
	int xincrement;
	int cincrement;
	int x        = (int)first->x + (((int)_ether_drivers_left_border) << _ETHER_SCREEN_FRACT_BITS);
	int y1       = (int)_ETHER_DRIVERS_ROUND_UP(first->y) + _ether_drivers_top_border;
	int y2       = (int)_ETHER_DRIVERS_ROUND_DOWN(last->y) + _ether_drivers_top_border;
	int y;
	int color    = first->red;
	int endcolor = last->red;
	//int lastcolor;
  
	if(y2 < y1)
		y2 = y1;
	xincrement = (int)ether_math_factor_multiply(_ether_drivers_slope_table[y2 - y1], (EtherScalar)(last->x - first->x));
	cincrement = (int)ether_math_factor_multiply(_ether_drivers_slope_table[y2 - y1], (EtherScalar)(endcolor - color));
	for(y = y1; y <= y2; ++y)
	{
		_ether_drivers_spans[y].startx     = _ETHER_DRIVERS_ROUND_UP(x);
		_ether_drivers_spans[y].startcolor = color;
		x += xincrement;
		//lastcolor = color;
		color += cincrement;
	}
	//if((lastcolor & 0xFF00) != (endcolor & 0xFF00)) 
	//	barf();
	return 0;
}

static int 
_ether_drivers_gscan_right_edge(EtherOutputvertex *first, EtherOutputvertex *last)
{
	int xincrement;
	int cincrement;
	int x        = (int)first->x + (((int)_ether_drivers_left_border) << _ETHER_SCREEN_FRACT_BITS);
	int y1       = (int)_ETHER_DRIVERS_ROUND_UP(first->y) + _ether_drivers_top_border;
	int y2       = (int)_ETHER_DRIVERS_ROUND_DOWN(last->y) + _ether_drivers_top_border;
	int y;
	int color    = first->red;
	int endcolor = last->red;
	//int lastcolor;
	if(y2 < y1)
		y2 = y1;
	xincrement = (int)ether_math_factor_multiply(_ether_drivers_slope_table[y2 - y1], (EtherScalar)(last->x - first->x));
	cincrement = (int)ether_math_factor_multiply(_ether_drivers_slope_table[y2 - y1], (EtherScalar)(endcolor - color));
	for (y = y1; y <= y2; ++y)
	{
		_ether_drivers_spans[y].endx = _ETHER_DRIVERS_ROUND_DOWN(x);
		_ether_drivers_spans[y].endcolor = color;
		x += xincrement;
		//lastcolor = color;
		color += cincrement;
	}
	//if ((lastcolor & 0xFF00) != (endcolor & 0xFF00))
	//	barf();
		return 0;
}

static int 
_ether_drivers_gscan_outline(EtherOutputvertex *list, void (*render_func)(void))
{
	EtherOutputvertex *v1 = list;
	EtherOutputvertex *v2 = list->next;
	EtherOutputvertex *v3 = list->next->next;
	EtherOutputvertex *vn;
	while(v3 != v1)
	{
		EtherOutputvertex *v;
		vn = v3->next;
		v1->next = v2;  v2->prev = v1;
		v2->next = v3;  v3->prev = v2;
		v3->next = v1;  v1->prev = v3;
		_ether_drivers_find_top(v1);
		if(_ether_drivers_starty >= _ether_drivers_endy)
			return 1;
		/* scan convert left-side edges */
		for(v = _ether_drivers_topvertex; v != _ether_drivers_botvertex; v = v->prev)
			if(_ether_drivers_gscan_left_edge(v, v->prev))
				return 1;
		/* scan convert right-side edges */
		for(v = _ether_drivers_topvertex; v != _ether_drivers_botvertex; v = v->next)
			if(_ether_drivers_gscan_right_edge(v, v->next))
				return 1;
		render_func();
		v2 = v3;
		v3 = vn;
	}
	return 0;
}
